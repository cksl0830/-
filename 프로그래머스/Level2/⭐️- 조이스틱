def solution(name):
    eng1="BCDEFGHIJKLMN" #13개
    eng2="ZYXWVUTSRQPO" #12개
    answer = 0 #이동 횟수
    count = -1  #커서 이동
    
    for i in range(len(name)):
        if name[i] in eng1+eng2:
            answer+=eng1.find(name[i])+1
            answer+=eng2.find(name[i])+1
            count+=1
        elif name[i]=='A' and len(name)-1!=i:
            temp1=0
            temp2=0
            if name[i+1] in eng2:
                temp1=(len(name)-2)+eng2.find(name[i+1])+1 #뒤로 돌아가기
                temp2=2+eng2.find(name[i+1])+1 #그대로 가기 
                if temp1>temp2:
                    count+=(len(name)-3)
                else:
                    count+=1
            elif name[i+1]=='A':
                for k in range(i+1,len(name)): 
                    if name[k] in eng1+eng2:
                        count+=1
                        break
                else:
                    break
                    
                    
            
                
    return answer+count
  
  
  # 내코드는 테케가 일부 돌아가지 않는다. 문제가 수정되어 모든 사람 코드가 돌아가지 않고 구글링해서 겨우 한개 찾았다..  
  
  
  // 다른 사람의 코드  
  
  def solution(name):
    init_A = list("A"*len(name))
    name=list(name)
    TF=[]
    for a,b in zip(name,init_A):
        TF.append(a==b)  
    count=move_count(TF,0,0)
    for alpa in name:
        tmp=ord(alpa)-ord("A")
        count+=min(ord(alpa)-ord("A"),ord("Z")-ord(alpa)+1)
    return count

def move_count(TF,point,count):
    if sum(TF)==len(TF):
        return count
    else:
        tmp_all=[]
        target_index=[]
        tmp_TF=TF.copy()
        target_index_count=0

        while len(target_index) <= 1:
            if not TF[(point+target_index_count)%len(TF)]:
                target_index.append((point+target_index_count)%len(TF))
            if not TF[(point-target_index_count)%len(TF)]:
                target_index.append((point-target_index_count)%len(TF))
            target_index_count+=1
        #print("TF:",TF)
        #print("point:",point)
        #print("접근:",set(target_index))

        for i in set(target_index):
            if not TF[i]:
                tmp_TF=TF.copy()
                tmp_TF[i]=True
                tmp_all.append(move_count(tmp_TF,i,count+min(len(TF)-abs(point-i),abs(point-i))))
        return min(tmp_all)
