def solution(name):
    # 문제풀이핵심: 알파벳 이동과 커서 이동횟수를 따로 구해서 둘의 합으로 결과 출력 
    
    answer = 0 #알파벳 이동
    move = len(name) - 1 #커서 이동
    
    while name[move] == 'A' and move>=0: #맨 마지막에 A가 오는 경우 제외하고 앞으로 커서 이동
        move -= 1
    if move<0: #문자가 A로만 되어있으면 0 출력 
        return answer
    
    
    for i in name: #알파벳 이동 최소값 
        answer += min(ord(i) - ord('A'), ord('Z') - ord(i) + 1)
    for i in range(len(name)): #문자 중간 A가 있는 경우 커서를 거꾸로 갈지 앞으로 갈지 move값 계산
        next = i+1
        while next < len(name) and name[next] == 'A':
            next += 1
        move = min(move, i+i+(len(name)-next), 2*(len(name)-next)+i)
        # 1. 앞으로 전진move값 / 2. 뒤로 돌아가기 / 3. 
        
    return answer+move
  
  // 다른 사람의 코드  
  
  def solution(name):
    init_A = list("A"*len(name))
    name=list(name)
    TF=[]
    for a,b in zip(name,init_A):
        TF.append(a==b)  
    count=move_count(TF,0,0)
    for alpa in name:
        tmp=ord(alpa)-ord("A")
        count+=min(ord(alpa)-ord("A"),ord("Z")-ord(alpa)+1)
    return count

def move_count(TF,point,count):
    if sum(TF)==len(TF):
        return count
    else:
        tmp_all=[]
        target_index=[]
        tmp_TF=TF.copy()
        target_index_count=0

        while len(target_index) <= 1:
            if not TF[(point+target_index_count)%len(TF)]:
                target_index.append((point+target_index_count)%len(TF))
            if not TF[(point-target_index_count)%len(TF)]:
                target_index.append((point-target_index_count)%len(TF))
            target_index_count+=1
        #print("TF:",TF)
        #print("point:",point)
        #print("접근:",set(target_index))

        for i in set(target_index):
            if not TF[i]:
                tmp_TF=TF.copy()
                tmp_TF[i]=True
                tmp_all.append(move_count(tmp_TF,i,count+min(len(TF)-abs(point-i),abs(point-i))))
        return min(tmp_all)
