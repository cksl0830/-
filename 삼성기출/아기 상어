# 아기상어 크기 2 / 상하좌우 
# 자기보다 작은 것만 먹을 수 있고, 같으면 이동만 가능, 크면 이동도 못함

# 먹을 수 있는 물고기 1이면 걔 먹으러
# 1보다 많으면 가장 최소 이동 -> 거리가 같으면 가장 위쪽, 그다음 가장 왼쪽 
# 먹을 수 있는게 더이상 없으면 끝 

# 아기상어 크기=먹은 물고기 수 :: 크기 +1 (이 조건으로 이동할 떄 제한걸림)
 
# 0 빈칸 / 1~6 물고기 크기 / 9 상어 위치 / 2 상어 크기  


from collections import deque 

n=int(input())
graph=[list(map(int,input().split())) for _ in range(n)]

dx=[0,0,-1,1] #상,하
dy=[1,-1,0,0] #우,좌

x,y=0,0
shark_size=2

# 상어 위치
for i in range(n):
    for j in range(n):
        if graph[i][j]==9:
            x=i
            y=j


def game(x,y,shark):
    distance = [[0] * n for _ in range(n)]
    visit = [[0] * n for _ in range(n)]
    
    q=deque()
    q.append((x,y))
    visit[x][y]=1
    temp=[]
    
    while q:
        a,b=q.popleft()
        for i in range(4):
            nx=a+dx[i]
            ny=b+dy[i]
            if 0<=nx<n and 0<=ny<n and visit[nx][ny]==0:
                if graph[nx][ny]<=shark:
                    q.append((nx,ny))
                    visit[nx][ny]=1
                    distance[nx][ny]=distance[a][b]+1 # 최소거리를 구하기 위해
                    if graph[nx][ny]<shark and graph[nx][ny]!=0: # 먹을 수 있는
                        temp.append((nx,ny,distance[nx][ny])) 
    return sorted(temp,key=lambda x: (x[2],x[0],x[1]))


count=0
time=0

while True:
    help = game(x,y,shark_size)
    if len(help)==0:
        break
    i,j,dist=help[0][0],help[0][1],help[0][2]
    
    time+=dist
    graph[x][y]=0 #상어 좌표 움직였으니 0 초기화 
    graph[i][j]=0  #먹었으니 0 초기화
    
    x,y=i,j #먹은 자리로 가서 다시 시작해야하므로
    count+=1 #먹은 수
    
    if count==shark_size:
        shark_size+=1
        count=0

print(time)
             
